#### 1.并发编程
   线程是并发编程的基础
  （1）线程中断
        1.1）线程对象提供了一个interrupt方法，可以对一个已经启动的线程进行中断操作。对一个线程执行interrupt操作后，
             有如下四种结果：
             1.1.1）如果被中断的线程正处于阻塞状态：包括阻塞于Object.wait()，Thread.join()，Thread.sleep()等方法，
                    那么该线程将收到一个InterruptedException，同时线程的中断状态将被设置为false；
             1.1.2）如果被中断的线程阻塞于java.nio.channels.InterruptibleChannel的IO操作，那么channel将被关闭，
                    并且该线程将的中断状态将被设置为true，同时该线程将收到一个java.nio.channels.ClosedByInterruptException；
             1.1.3）如果被中断的线程阻塞于java.nio.channels.Selector，那么阻塞的方法将立即返回，同时线程的中断状态将被设置为true；
             1.1.4）如果不是以上3种情况，那么被中断线程的中断状态将被设置为true。
             可见线程的interrupt方法只是给线程设置了一个中断状态或者让线程中阻塞的方法通过抛异常的方式返回。
  （2）线程休眠
        1.1）上述的代码示例中我们已经用到了Thread.sleep()方法，该方法是让当前线程休息一定的时间后，再继续执行。需要指出的是，
             在执行该方法后，当前线程并不会释放锁，在高并发的场景下可能会导致其他线程无法获取锁从而造成性能问题，因此要慎用该方法。
  （3）等待线程执行完毕
        1.1）在一个线程中等待另一个线程执行完毕（等待线程执行完毕才继续往下执行），只需要调用线程对象的join()方法即可。
  （4）线程的停止
        1.1）当线程的run()方法执行完毕，线程会自然的停止。那么问题来了，怎么让一个运行状态中的线程停止呢？JDK中的Thread提供了
             一个静态方法stop()，不过目前已经废弃了。因为stop方法在线程停止的同时会让线程释放已经获取的锁，这会导致其他排队
             等待锁的线程获取锁，从而导致不可预知的情况。所以，官方已经不建议使用Thread.stop()方法了。
             那么，停止线程的正确姿势是什么？JDK中建议用一个自定义的变量用于标识线程是否需要退出，然后线程不断地去检查该变量
             从而决定要不要从run方法退出；或者调用线程对象的interrupt方法，通过中断异常来退出执行。
  （5）守护线程
       特点：
       1.1）也是个线程。
       1.2）既然是个守护线程，肯定有其他线程一块，才能算是守护，如果不存在其他线程，守护线程自己也是不存在的。
       1.3）主要用于清理工作，比如后台任务，整个主业务退出后，进度的清理。
       1.4）守护线程先执行，其他线程再执行，等其他线程执行完毕，守护线程自动终止
  （6）线程异常
        1.1）子线程异常不会传到主线程

#### 2.线程安全
   1）平时不建议用静态的变量（常量可以），容易出现线程共享问题，因为都是放在堆上的，堆内存区域是多个线程共享的。
   2）线程安全是针对多线程程序来说的，如果多个线程同时读写一个共享变量，就会造成最终结果与预期不一致的问题，这种问题就是线程安全问题。
   3）共享变量：多个线程都能访问的变量，通常是静态变量或类的成员变量。为啥这两类变量是共享的啊？因为他们存放在JVM的堆上，
      JVM堆上的内存区域是多个线程共享的。
   4）解决线程安全的问题，常用的就是锁，用sychronized或者ReentrantLock。本质是保证临界区代码的原子性，保证同一时刻只能有一个线程执行。 

#### 3.线程池
   1）Java中的一个线程要对应操作系统中的一个线程资源，而操作系统的线程资源是有限的，如果我们在每一次客户端请求到来时都新起一个线程那
      显然是有问题的。那么，如何在利用多线程提升性能的同时又解决线程的占用问题呢？答案就是线程池，线程池可以设置线程的上限，在请求量
      较大时复用线程，在请求量较小时关闭线程，在提升系统性能的同时解决高并发时线程资源的占用问题。
   2）阻塞队列是无限队列（没有大小），搞了无限队列，那么最大的核心线程数就不会起作用，因为永远到不了（如题例子），能创建的线程数就是核心线程数。
   3）线程池的工作原理：线程池接收到一个新任务时，会判断当前已经启动的线程个数是否超过corePoolSize，若未超过则启动一个新的线程来
      处理请求；否则，判断阻塞队列workQueue中的任务个数是否超过上界，若未超过上界，则将任务放入阻塞队列，否则，判断线程池中的
      当前线程个数是否超过maximumPoolSize，若超过则执行拒绝策略，否则启动新的线程执行任务。
      如题：corePoolSize=5,
         maxPoolSize=10,
         blockingQueueSize=200
        1000个任务提交（一般是并发），分析原理？
            回答：1 启动5线程处理
                 2 200个任务放到阻塞队列
                 3 再启动10-5=5个线程处理
                 4 还剩下1000-210=790个任务，执行拒绝策略（执行不过来了）
         