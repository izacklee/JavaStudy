### 1.锁
    （1）获得lock对象
    （2）可以手动指定在什么地方，获得锁和释放锁
    （3）可以参考同步

### 2.重入锁/读写锁
    （1）什么是读写锁：
        1）如果没有写，那么所有线程都可读
        2）如果有写，那么其他所有线程不可读写
    （2）读写锁的三个特性
        1）公平和不公平：
            a.公平：获取锁的顺序就是调用锁的顺序
            b.不公平（默认）：获取锁的顺序和调用锁的顺序没有关系，相对来说，非公平锁的效率更高
        2）重进入：读锁和写锁，都支持线程重进入（重入）；即一个线程可以同时拥有读锁和写锁。
        3）锁降级：获取写锁->获取读锁->释放写锁=保留读锁（即：写锁降级为读锁）
        
### 3.信号量
    当信号量满的时候，线程进入等待，不满时才可以继续添加。

### 4.阻塞队列
    当阻塞队列满的时候，进入等待，分为阻塞和非阻塞两种操作方式。
    
### 5.阻塞栈
    支持FIFO(First Input First Output)和FILO(First Input Last Output)两种操作方式。
    是一个双向链表，分为阻塞和非阻塞两种操作方式。
    
    线程池其实就是一个大集合，一个是队列，一个是栈。
    一般情况下，避免使用线程。
    
### 6.条件变量
    相当于等待和唤醒，这样的线程调度，主要是针对于某一个锁对象的操作。
    
### 7.原子量
    针对于java中所有的数据类型（基本数据类型、引用数据类型、数组），设计的一种原子化操作的变量。
    原子量是对旧值有可见性的。
        (1) 注意！！！！：原子量操作，只能保证该原子量自己的安全，
            如果涉及到其他公用变量，依然存在线程安全问题，所以在使用原子量的时候，建议依然使用锁。

### 8.障碍器  
    必须等所有子线程执行完毕以后，主线程才执行。实际上是子线程通知后，进入等待状态，
    子线程执行完毕后，唤醒所有主线程的等待。
    
    项目需求文档（案例）：
    https://wenku.baidu.com/view/5ef15ec8bdeb19e8b8f67c1cfad6195f312be827.html?from=search
    https://wenku.baidu.com/view/bd4813c958fb770bf78a55f6.html?from=search
    