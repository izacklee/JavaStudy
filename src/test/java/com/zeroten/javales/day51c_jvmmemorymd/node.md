#### 1.volatile 
   a.volatile 的作用是保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，
   其他线程立马可见（用volatile关键字修饰的变量会存入堆内存中(不修饰则在主内存中) 堆内存值是共享的），避免出现脏读的现象。
   如isShutDown被置为true后，后面的代码doWork方法仍有执行。如用volatile修饰isShutDown变量，可避免此问题。
   b.volatile对变量的单个读/写具有原子性，但不能做到复合操作的原子性，例如volatile++。
   如果要实现复合操作的原子性，建议使用java.util.concurrent.atomic包下的Atomic类；
  （1）JMM（Java Memory Model Java内存模型）针对编译器指定的重排序规则表
     是否能重排序        第二个操作
        第一个操作       普通读/写       volatile读       volatile写
        普通读/写                                             NO
        volatile读       NO              NO                  NO
        volatile写                       NO                  NO
    举例说明，第三行最后一个单元格的意思是：在程序顺序中，单第一个操作为普通变量的读或写时，
    如果第二个操作为volatile写，则编译器不能重排序这两个操作。
    从上表可以看出：
        a 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile
        写之前的操作不会被编译器重排序到volatile写之后。
        b 当第一个操作为volatile读时，第二个操作无论是什么，都不能重排序。这个规则确保volatile
        读之后的操作不会被编译重排序到volatile写之后。
        c 当第一个操作是volatile写时，第二个操作是volatile读/写时，不能重排序。
  （2）内存屏障
      （2.1）内存屏障中的两个指令：
            Store：将处理器缓存的数据刷新到内存中。
            Load：将内存存储的数据拷贝到处理器的缓存中。
        屏障类型				指令示例						说明
        LoadLoad Barriers	Load1;LoadLoad;Load2	    该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作
        StoreStore Barriers	Store1;StoreStore;Store2	该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的
                                                            操作先于Store2及其后所有存储指令的操作
        LoadStore Barriers	Load1;LoadStore;Store2	    确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作
        StoreLoad Barriers	Store1;StoreLoad;Load2	    该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令
                                                            的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,
                                                            才执行该屏障之后的内存访问指令
  （3）Java程序的内存可见性，按程序可分为三类
      （3.1）单线程程序。单线程程序不会出现内存可见性问题（因所有的缓存等都是在同一个核心cpu里）。
      （3.2）正确同步的多线程程序。
      （3.3）未同步/未正确同步的多线程程序。只有正确同步才能保证内存可见性，未同步以及未正确同步的都不能。

#### 2 垃圾回收
  （1）加载流程：.class文件（二进制数据）->读取到内存->数据放进方法区->堆中创建对应Class对象->并提供访问方法区的接口
    （1.1）二进制数据来源：
        （1.1.1）从本地磁盘读取class文件
        （1.1.2）通过网络下载.class文件
        （1.1.3）从zip，jar等归档文件中加载.class文件
        （1.1.4）从数据库中提取.class文件
  （2）验证、准备、解析
    （2.1）验证主要是用来检查class文件格式是否正确
    （2.2）准备阶段：为变量分配内存
        public static int test = 100; // 准备阶段，test = 0;
        public int test2 = 100;
        public static final int test3 = 100; // 准备阶段，test3 = 100;  被final修饰会放入常量池
    （2.3）解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，一般不关注。
  （3）初始化
    （3.1）初始化是虚拟机要把类读到虚拟机里，这个才叫初始化。
    （3.2）初始化阶段，用户定义的java程序代码才真正开始执行。
    （3.3）对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块）。
    （3.4）初始化某个子类，则父类也肯定被初始化。
    （3.5）访问被final修饰的静态变量，不会被初始化（执行静态代码块）。
  （4）类加载器
    （4.1）在java里加双亲委派模型（父类加载失败，由子类加载器自己处理）。
            双亲委派模模型是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先
                去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上
                委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，
                倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型
            好处：
                a 比如自定义一个java.lang.String，如果找不到自定义的，会直接用核心包里的
                b 避免直接使用核心包里的api，造成安全隐患。