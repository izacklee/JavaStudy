#### 1.CPU工作原理
  （1）cpu执行快，内存读写慢
       如何提高cpu的利用率，那就是让cpu不停的运转。
  （2）重排序（打乱顺序），并发时执行顺序可能会变化（不一定按顺序） 
        解决：
           （2.1）用volatile修饰符解决（只能用于单个变量）
           （2.2）用数据依赖性解决，比如：a = 1; b = a;
           （2.3）as-if-serial（编译器和运行器的实现原则）语义意思是：不管怎么重排序（编译器和处理器为了提高并行度），
                （单线程）执行结果都不会被改变。 
#### 2.并发编程的问题
   （1）原子性：一个操作中cpu要么执行完成，要么不执行。
        哪些操作具有原子性？
        x = 10;      √
        y = x;       ×
        x++;         ×
        x = x + 1;   ×
        x = new x(); ×
    （2）可见性：多线程下访问同一个变量，一个线程修改了该变量的值，其他线程可以立即看到修改的值。（volatile，锁）   
    （3）有序性：程序执行按照代码先后顺序执行。（happens-before）
      线程不能乱用，像重运算的操作，效率低。
          因线程重复切换，cpu得不到充分利用。想提高效率，其实就是让cpu不停歇的运作（如io 读写数据库等）。
#### 3.Java内存模型
  （1）内存模型
     （1.1）内存模型定义了内存系统中多线程读写操作行为的规范，保证读写操作指令执行的正确性。
     （1.2）解决CPU多级缓存、处理器优化、指令重排导致的内存访问问题。
     （1.3）保证并发场景下对内存访问的一致性，原子性和有序性。
  （2）内存屏障
     （2.1）解决缓存不能实时更新的问题。用volatile关键字修饰变量的方式解决。
     （2.2）内存屏障的作用：
           （2.2.1）阻止重排序。
           （2.2.2）强制写回主内存，让缓存数据失效。
  （3）happens before规则
       happens before保证了一个操作的结果对另一个操作可见（行代码的运行，前一行运行的结果对下一行运行可见）。
       （在Java内存模型中，happens-before 应该翻译成：前一个操作的结果可以被后续的操作获取。
            讲白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。）
      （3.1）如果A happens before B，那么A的操作结果对B可见（意思是执行完A之后 B可以拿到A最新的结果），且A的执行顺序在B之前。
      （3.2）两个操作之间存在happens before关系，并不意味着java平台的具体实现必须按照happens
            before关系指定的顺序来执行。可以允许重排序之后的执行结果，与happens before关系来执行的结果一致。        